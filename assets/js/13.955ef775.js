(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{184:function(e,n,t){"use strict";t.r(n);var o=t(0),v=Object(o.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h2",{attrs:{id:"js数据类型（分类，区别，判断）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js数据类型（分类，区别，判断）","aria-hidden":"true"}},[e._v("#")]),e._v(" JS数据类型（分类，区别，判断）")]),e._v(" "),t("div",{staticClass:"tip custom-block"},[t("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),t("p",[e._v("关于数据类型方面的知识点很多，小弟主要从数据类型的"),t("code",[e._v("分类")]),e._v("，"),t("code",[e._v("区别")]),e._v("，"),t("code",[e._v("类型判断")]),e._v("三个角度来总结下，如有不当，还望路过的各位大佬给予指正！")])]),e._v(" "),t("h3",{attrs:{id:"分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分类","aria-hidden":"true"}},[e._v("#")]),e._v(" 分类")]),e._v(" "),t("p",[e._v("最新的 ECMAScript 标准定义了8种数据类型"),t("br"),e._v(" "),t("code",[e._v("数字（Number）")]),e._v("、"),t("code",[e._v("字符串（String）")]),e._v("、"),t("code",[e._v("布尔值（Boolean）")]),e._v("、"),t("code",[e._v("undefined")]),e._v("、"),t("code",[e._v("null")]),e._v("、"),t("code",[e._v("任意精度的整数 (BigInt)")]),e._v("、"),t("code",[e._v("Symbol（ES6 新添加的一种类型）")]),e._v("、"),t("code",[e._v("对象（Object）")]),e._v("      。其中对象类型包括："),t("code",[e._v("数组（Array）")]),e._v("、"),t("code",[e._v("函数（Function）")]),e._v("、还有两个特殊的对象："),t("code",[e._v("正则（RegExp）")]),e._v(" 和 "),t("code",[e._v("日期（Date）")]),e._v("。")]),e._v(" "),t("p",[e._v("关于"),t("code",[e._v("BigInt")]),e._v("和"),t("code",[e._v("Symbol")]),e._v("类型不太常用,因此我们在这里就不过多讨论了,下面通过几个不同角度对常用的6种数据类型进行下归类。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("按存储类型分类"),t("br")]),e._v(" "),t("ul",[t("li",[e._v("基本类型："),t("code",[e._v("数字（Number）")]),e._v("、"),t("code",[e._v("字符串（String）")]),e._v(" 、"),t("code",[e._v("布尔值（Boolean）")]),e._v("、 "),t("code",[e._v("undefined")]),e._v("、"),t("code",[e._v("null")])]),e._v(" "),t("li",[e._v("引用类型："),t("code",[e._v("对象（Object） 其中包括 Array、Function、RegExp、Date")])])])]),e._v(" "),t("li",[t("p",[e._v("按是否可变分类")]),e._v(" "),t("ul",[t("li",[e._v("可变类型："),t("code",[e._v("对象（Object） 其中包括 Array、Function、RegExp、Date")])]),e._v(" "),t("li",[e._v("不可变类型：："),t("code",[e._v("数字（Number）")]),e._v("、"),t("code",[e._v("字符串（String）")]),e._v(" 、"),t("code",[e._v("布尔值（Boolean）")]),e._v("、 "),t("code",[e._v("undefined")]),e._v("、"),t("code",[e._v("null")])])])]),e._v(" "),t("li",[t("p",[e._v("按是否可拥有方法分类")]),e._v(" "),t("ul",[t("li",[e._v("可拥有方法类型："),t("code",[e._v("数字（Number）")]),e._v("、"),t("code",[e._v("字符串（String）")]),e._v(" 、"),t("code",[e._v("布尔值（Boolean）、对象（Object）")])]),e._v(" "),t("li",[e._v("不可拥有方法类型："),t("code",[e._v("null、undefined")])])])])]),e._v(" "),t("h3",{attrs:{id:"基本类型和引用类型区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本类型和引用类型区别","aria-hidden":"true"}},[e._v("#")]),e._v(" 基本类型和引用类型区别")]),e._v(" "),t("ul",[t("li",[e._v("基本类型的值不可变，引用类型值可变"),t("br")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//基本数据类型\nvar a = 'abc';\nvar b= 123;\na = 'def';\nb = 456;\nconsole.log(a) //def\nconsole.log(b) //456\n")])])]),t("p",[e._v("可能我们会使用上面这个栗子来推翻基本数据类型的值不可变，但其实这里并不冲突，用 "),t("code",[e._v("var a = 'abc' a = 'def'")]),e._v("来说明，\n首先声明一个变量"),t("code",[e._v("a")]),e._v(" 并给其赋值"),t("code",[e._v("abc")]),e._v("， 这个时候在栈内存中会为"),t("code",[e._v("a")]),e._v("变量开辟一块空间来存储"),t("code",[e._v("abc")]),e._v("这个值，当将值更改为"),t("code",[e._v("def")]),e._v("的时候，会将之前变量"),t("code",[e._v("a")]),e._v("(栈内存中标识符a)之前对应的值整体给"),t("code",[e._v("覆盖掉")]),e._v("，然后存入新值，此时"),t("code",[e._v("a")]),e._v("的值就成了"),t("code",[e._v("def")]),e._v("。因此，分析后，我们会发现，对于基本数据类型，并不是对原始值的操作，而是将原始值覆盖后重新给变量赋新值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//引用数据类型\n var cat = {};\n cat.name = 'Tom';\n cat.age = 12;\n console.log(cat) //{name: \"Tom\", age: 12}\n cat.name = 'candy'\n cat.age = '10'\n console.log(cat) //{name: \"candy\", age: 10}\n")])])]),t("p",[e._v("对于引用类型，我们可以清晰的看到是可以通过操作指针的方式来修改存储在堆内存中的对象的属性值。")]),e._v(" "),t("ul",[t("li",[e._v("基本类型不能添加属性和方法，引用类型可以添加属性和方法")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//基本数据类型\nvar base = 'base';\nbase.attr = 'attr';\nbase.method = function(){//...};\nconsole.log(base.attr); // undefined\nconsole.log(base.method); // undefined\n\n//引用数据类型\nvar cat = {};\ncat.name = 'Tom';\ncat.age = 10;\ncat.sing = function(){console.log(cat.name + 'sing');} \ncat.sing();// 'Tom sing'\n")])])]),t("ul",[t("li",[e._v("基本类型的比较是值的比较，引用类型的比较是引用的比较")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//基本数据类型\nvar a = 1;\nvar b = true;\nvar c = '1';\nconsole.log(a == b);//true\nconsole.log(a === b);//false\nconsole.log(a == c);//true\nconsole.log(a === c);//false\n")])])]),t("p",[e._v("这个栗子，其实是为了说明基本数据类型的比较是值的比较，只有当两者的值相等的情况下它们才相等，但栗子中的布尔类型和数字类型使用"),t("code",[e._v("==")]),e._v("符号比较会相等，其实是"),t("code",[e._v("类型转换")]),e._v("和"),t("code",[e._v("==")]),e._v("符号本身特性作用的结果，因此，这里也暴露出一个使用问题就是当我们在实际应用中尽量使用"),t("code",[e._v("===")]),e._v("对数据进行比较，从而消除因类型转换导致的不符合预期效果的错误结果。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//引用数据类型\nvar obj1 = {};\nvar obj2 = {};\nconsole.log(obj1 == obj2); // false\n")])])]),t("p",[e._v("为什么不相等呢？答案显而易见，就是因为引用类型的比较是引用地址的比较，"),t("code",[e._v("obj1")]),e._v("和"),t("code",[e._v("obj2")]),e._v("是两个独立声明的变量，所以"),t("code",[e._v("堆")]),e._v("内存中所分配的空间是不同的区域，那么引用地址也是不相同的，相当于两个不同房间对应的房间号是不同的，对比引用地址，地址不同，所以就不相等。")]),e._v(" "),t("ul",[t("li",[e._v("基本类型存储在栈内存，引用类型存储在栈内存和堆内存"),t("br"),e._v(" "),t("ul",[t("li",[e._v("基本类型数据的存储位置是在      "),t("strong",[e._v("栈内存")]),e._v(" 中，会将声明变量的"),t("code",[e._v("标识符，值")]),e._v("进行存储，我的看法是因为基本类型的数据结构简单以及占用内存空间小的原因。")]),e._v(" "),t("li",[e._v("引用类型数据的存储位置分两部分："),t("strong",[e._v("栈内存")]),e._v(" 存储声明变量的"),t("code",[e._v("标识符")]),e._v("和指向"),t("code",[e._v("堆内存")]),e._v("中存储的值的"),t("code",[e._v("指针")]),e._v("，\n"),t("strong",[e._v("堆内存")]),e._v(" 存储实际的值（对象），外部访问的时候是通过"),t("code",[e._v("指针")]),e._v("来间接访问到数据对象。")])])])]),e._v(" "),t("h3",{attrs:{id:"类型判断"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类型判断","aria-hidden":"true"}},[e._v("#")]),e._v(" 类型判断")]),e._v(" "),t("ul",[t("li",[e._v("typeof"),t("br")])]),e._v(" "),t("p",[t("code",[e._v("typeof")]),e._v(" 运算符用来判断数据类型，它会返回一个表示数据类型的字符串，它可以准确判断的数据类型有"),t("code",[e._v("number")]),e._v("、"),t("code",[e._v("string")]),e._v("、"),t("code",[e._v("boolean")]),e._v("、"),t("code",[e._v("undefined")]),e._v("、"),t("code",[e._v("function")]),e._v("，但对于"),t("code",[e._v("null")]),e._v("和除过"),t("code",[e._v("function")]),e._v("以外的引用类型就力不从心，均会返回"),t("code",[e._v("object")]),e._v("。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" typeof 1; // number\n typeof '';//string\n typeof true; //boolean\n typeof undefined; //undefined\n typeof new Function(); //function\n typeof null; //object 无效\n typeof [] ; //object 无效\n typeof new Date(); //object 无效\n typeof new RegExp(); //object 无效\n")])])]),t("ul",[t("li",[e._v("instanceof"),t("br"),e._v(" "),t("code",[e._v("instanceof")]),e._v("  运算符用于检测构造函数的 "),t("code",[e._v("prototype")]),e._v(" 属性是否出现在某个实例对象的原型链，这是官方的解释，感觉有点绕，简单的讲就是判断运算符左操作数对象的原型链上是否有右边这个构造函数的 "),t("code",[e._v("prototype")]),e._v("属性，也就是说指定对象是否是某个构造函数的实例，最后返回布尔值。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var num = 123\nnum instanceof Number //false\n[] instanceof Array; //true\n[] instanceof Object; //true\n{} instanceof Array; //false\nnew Date() instanceof Date;//true\nnew Date() instanceof Object;//true\nfunction Person(){};\nnew Person() instanceof Person;//true\nnew Person() instanceof Object;//true\n\n")])])]),t("p",[e._v("首先说明一点，instanceof 运算符只能用于引用类型的判断，无法应用于基本数据类型判断。从上面这个栗子我们可以看出所有的引用类型数据都是 Object类型的实例（原型链的顶端就是"),t("code",[e._v("Object")]),e._v("对象），因此在实际应用中一般使用"),t("code",[e._v("xxx instanceof Array")]),e._v("或者"),t("code",[e._v("xxx instanceof Function")]),e._v("，而不会使用"),t("code",[e._v("xxx instanceof Object")]),e._v("。")]),e._v(" "),t("ul",[t("li",[e._v("Object.prototype.toString"),t("br")])]),e._v(" "),t("p",[e._v("首先看一个栗子")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('    const dataArr = [1,\'str\',true,null,undefined,{},[],new Function(),new Date(),new RegExp()];\n    \n    for(let item of dataArr) {\n        const type = typeOf(item);\n        console.log(type); \n        //依次返回：number、 string、 boolean、 null、 \n        //undefined、 object、 array、 function、 date、 regExp\n    }\n             \n    function typeOf(obj) {\n        const toString = Object.prototype.toString;\n        const map = {\n            "[object Boolean]": "boolean",\n            "[object Number]": "number",\n            "[object String]": "string",\n            "[object Function]": "function",\n            "[object Array]": "array",\n            "[object Date]": "date",\n            "[object RegExp]": "regExp",\n            "[object Undefined]": "undefined",\n            "[object Null]": "null",\n            "[object Object]": "object"\n        };\n        return map[toString.call(obj)]; //Object.prototype.toString.call(obj) 或者 Object.prototype.toString.apply(obj)\n    }\n\n')])])]),t("p",[e._v("可以看到"),t("code",[e._v("toString()")]),e._v("几乎可以准确检测所有的数据，因此是一个具有普遍适用性的通用方法。并且使用的时候需要采用"),t("code",[e._v(".call（.apply）")]),e._v("的调用方式，这里主要原因是默认情况下（"),t("code",[e._v("toString")]),e._v("方法没有被复写），该方法会默认返回其调用者的具体类型，也就是"),t("code",[e._v("toString")]),e._v("运行时this指向的对象类型, 其返回的类型格式为"),t("code",[e._v("[object,xxx]")]),e._v("。所以使用"),t("code",[e._v(".call(thisArg)")]),e._v("或者"),t("code",[e._v(".apply(thisArg)")]),e._v("，"),t("code",[e._v("thisArg")]),e._v("参数就是我们需要检测的目标，也就是"),t("code",[e._v("this")]),e._v("所指的调用对象，这样就会返回当前检测目标的准确数据类型。")])])}],!1,null,null,null);n.default=v.exports}}]);